---
title: "Map quadrat"
author: "maurolepore@gmail.com"
date: '2017-11-29'
output:
  html_document:
    theme: united
    df_print: paged
    toc: yes
    toc_depth: '6'
  html_notebook:
    theme: united
    toc: yes
    toc_depth: 6
subtitle: A prototype
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  fig.show = "hold",
  out.width = "98%",
  fig.align = "center",
  fig.width = 7.5, 
  fig.asp = 0.9
)

options(dplyr.print_min = 10, dplyr.print_max = 10)
```

# Overview

```{r hide-note1, include=FALSE}
# Here I build a tool for data science that can be used as a scipt, as a
# function, and as an web application. None of those interfaces is better or
# worse the any other. From a user's perspective, each interface is useful in
# some context; and from a developer's perspective, the flow from script to
# web-application moves the focus from implementation details to abstraction;
# and from shifting the focus from the developer to the user.
```

The job is to map the position of trees within a quadrat. Later, the task will be to iterate over each quadrat in a data set. The example data set is a subset of a public data set of trees censuses on Barro Colorado Island, Panama (source: https://repository.si.edu/handle/10088/20925).

# Setup

I'l use __dplyr__ and __ggplot2__ for data wrangling and visualization. Also, I'll use __ggrepel__ to avoid overlaping on the maps; [__try__](https://github.com/forestgeo/try) which contains an example dataset; and __assertive__, to assert some important aspects of the data.

```{r}
# Ensure random operations are reproducible
set.seed(1014)

library(try)
library(assertive)
library(ggrepel)
library(ggplot2)
library(dplyr)
```

# Script

This section develops a script that prototypes one way to do this job. The code style I use is based on [The tidyverse style guide](http://style.tidyverse.org/); I aim not to minmimize lines of code but to maximize readablilty. I need to re read this code later and understand it quickly. I start by glimpsing the example data set.

```{r}
# Example data set
example_data <- try::bci12vft_mini
glimpse(example_data)
```

## Check input

All quadrats should come from a single research plot. I'll check if this true.

```{r}
censuses_n <- unique(example_data$PlotID)
is_of_length(censuses_n, 1)
```

Should the data set contain multiple plots, I would reject the data and ask the user to filter a single plot. The user should then do something like this:

```{r}
this_plotid <- 1
filtered_plotid <- filter(example_data, PlotID == this_plotid)
```

A detail of the taks is that users will likely want to map trees which diameter (variable `DBH`) is greater than 10 cm. But that particular value of diameter may vary. The code will be inclusive; it'll accept trees of all diameters and will only warn if it detects trees smaller or equal than 10 cm.

```{r}
# Expecting to reuse this code
check_dbh <- function(x, limit) {
  if (any(x <= limit)) {
    warning("The diameter of some trees is smaller or equal to ", limit, " cm")
  } else{
    invisible()
  }
}
check_dbh(filtered_plotid$DBH, 10)
```

I'll be up to the user to exclude trees smaller than the desired limit.

```{r}
over_limit <- filter(filtered_plotid, DBH > 10)
# Silent means that filtering was successful
check_dbh(over_limit$DBH, 10)
```

## Map

### Requirements

For now I'll focus on a single quadrat. (I'll work later on the code to iterate over multiple quadrats.)

```{r}
# Choosing one quadrat at random
this_quadrat <- sample(over_limit$QuadratName, 1)
one_quadrat <- filter(over_limit, QuadratName == this_quadrat)
```

The requirements are quoted below; they come from a private email (via [@](https://mail.google.com/mail/u/0/?zx=yxdmg1oh1mf4#search/is%3Aunread+OR+has%3Apurple-question/1600a06b2c2f4304))

* 1. Status: I'll map the `Status` of each stem to a the ending of each label. This is a better alternative than mapping to, say point shape, because each tree `Tag` has multiple stems associated to them, and they will reppel each other. If the `Status` was mapped to shape, multiple points will plot on top of each other and the overlapping will obscure the information.

>  It would be nice to include the status. I used to put a "D" (dead) or an "R"(stem lost or broken) after the tag number to differentiate them from the live trees. For example, 8334D or 8145R.

* 2. I won't label subquadrats inside eadh quadrat.

>  I don't need the subquadrat labels, since they are the same for every quadrat.

* 3. I'll fix the quadrat size to 20x20m. I'll keep in mind that this may need to be flexible in the future.

> 3. [In] most sites, the quadrats are 20x20 meters.

* 4. I'll map the shape of the point to an empty circle, and will map its size to the size of each tree, standarized by the number of trees the quadrat.

> It would be nice to have a larger circle for the larger trees so that the field workers can look for a large tree. However, for very crowded quadrats, we can ignore this or make the circles smaller than if there are less trees. In my script, I count the number of trees in that quadrat and calculate the size depending on the number.

* 5. Shape and position:

    * I'll map live trees to a circular shape. 
    * I'll map the position of each tree to a point, using the variables `x` and `y`.
    * Also, I'll map the position to the `Tag` name of each tree -- that way field workers will know what tree they expect to find where. To avoid overlap, I'll implement repulsive labels with `ggrepel::geom_text_repel()`.

> 5. For the live trees, yes, please use circles (tree trunks tend to be circular). But you are welcome to use other symbols for the "other" categories.

* 6. I'll remove all text from the axes;

> The reason I don't have the tick legends is to give more space to the map on the page.

* 7. I'll set the direction of the axes ticks to inward;

> Same reason as above, to make the map as large as possible on the page. However, I wouldn't mind if they are outwards.

* 8. I'll set the count of axes ticks to one meter along the range of `x` and `y` values;

> Yes, so that the field workers can orient themselves on the maps and more carefully draw the location of the trees.

* 9. I'll set one grid line every 5 meters along the range of `x` and `y` values;

> Yes, each grid represents a 5x5 m subquadrat. This is how the plots are physically gridded in the field.

* 10. I'll set he type of the grid lines to dashed.

> Dashed seems to me to be better than solid.

* 11. I'll add a one-line title; I'll to this at the top of the code to help visualize where on the plot each code chunk is doing its job.

> ... would be great if I can manually choose the title.

> The plotname in ViewFullTable carries the name of the plot.

* 12. I'll add a multi-line subtitile, wich I'll do in advance to avoid cluttering the code of the plot. Also, placing this code under the title will help to visualize where on the plot this code chunk is doing its job.

> I think each site would like to be able to type in their subheaders.

* I'll set the background colour to white;

(Eventually I'll let the user adjust these options -- but I'll do that later; now I focus on getting the maps close to the most common requirement.)

### Helpers

```{r}
theme <- theme(
  panel.background = element_rect(fill = "white"),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  legend.position = "none",
  plot.title = element_text(size = 20),
  plot.subtitle = element_text(size = 12),
  axis.text = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  axis.ticks.length = unit(-0.1, "cm")
)

# Used to add first letter of `Status` to each tree `Tag`
add_first_letter <- function(x, y) {
  paste0(x, ".", sub("^(.).*$", "\\1", y))
}
```

### Plot

```{r params}
# Parameters that will likely become arguments of a function
lim_min <- 0
lim_max <- 20
subquadrat_side <- 5
size_label <- 2
# Adjust a margin around the plot area that ggplot2 inserts by default
offset <- 1
title <- paste("My Title", unique(one_quadrat$QuadratName), sep = ", ")
header <- paste0(
  "Nombres y fecha:           Revisado por:                Entrado en PC por:\n",
  "                                                                          \n",
  "__________________  __________________  __________________\n",
  "__________________  __________________  __________________\n",
  "__________________  __________________  __________________\n"
)
```

```{r plot}
# Plot
ggplot(data = one_quadrat, aes(x = x, y = y)) +
  geom_point(aes(size = DBH / length(DBH)), shape = 1) +
  geom_text_repel(
    aes(label = add_first_letter(Tag, Status)), 
    size = size_label
  ) +
  labs(
    title = title,
    subtitle = header,
    x = NULL, y = NULL
  ) +
  geom_vline(
    xintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  geom_hline(
    yintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  coord_fixed(
    xlim = c(lim_min + offset, lim_max - offset), 
    ylim = c(lim_min + offset, lim_max - offset)
  ) +
  scale_x_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  scale_y_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  theme
```


