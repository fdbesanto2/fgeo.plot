---
title: "Map quadrat"
author: "maurolepore@gmail.com"
date: '2017-11-29'
output:
  html_document:
    theme: united
    df_print: paged
    toc: yes
    toc_depth: '6'
  html_notebook:
    theme: united
    toc: yes
    toc_depth: 6
subtitle: A prototype
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  fig.show = "hold",
  out.width = "98%",
  fig.align = "center",
  fig.width = 7.5, 
  fig.asp = 0.9
)

options(dplyr.print_min = 10, dplyr.print_max = 10)
```

# Overview

```{r hide-note1, include=FALSE}
# Here I build a tool for data science that can be used as a scipt, as a
# function, and as an web application. None of those interfaces is better or
# worse the any other. From a user's perspective, each interface is useful in
# some context; and from a developer's perspective, the flow from script to
# web-application moves the focus from implementation details to abstraction;
# and from shifting the focus from the developer to the user.
```

The job is to map the position of trees within a quadrat. Later, the task will be to iterate over each quadrat in a data set. The example data set is a subset of a public data set of trees censuses on Barro Colorado Island, Panama (source: https://repository.si.edu/handle/10088/20925).

# Setup

I'l use __dplyr__ and __ggplot2__ for data wrangling and visualization. Also, I'll use __ggrepel__ to avoid overlaping on the maps; [__try__](https://github.com/forestgeo/try) which contains an example dataset; and __assertive__, to assert some important aspects of the data.

```{r}
# Ensure random operations are reproducible
set.seed(1234)

library(try)
library(assertive)
library(ggrepel)
library(ggplot2)
library(dplyr)
```

# Script

This section develops a script that prototypes one way to do this job. The code style I use is based on [The tidyverse style guide](http://style.tidyverse.org/); I aim not to minmimize lines of code but to maximize readablilty. I need to re read this code later and understand it quickly. I start by glimpsing the example data set.

```{r}
# Example data set
# example_data <- sinharaja::sinh_vft
example_data <- try::bci12vft_mini


glimpse(example_data)
```

## Check input

### Check single plot; reject if not multiple plots are detected

All quadrats should come from a single research plot. I'll check if this true.

```{r}
censuses_n <- unique(example_data$PlotID)
is_of_length(censuses_n, 1)
```

Should the data set contain multiple plots, I would reject the data and ask the user to filter a single plot. The user should then do something like this:

```{r}
this_plotid <- 1
filtered_plotid <- filter(example_data, PlotID == this_plotid)
```

### Check tree diameter; warn if trees smaller than a common limit are detected

A detail of the taks is that users will likely want to map trees which diameter (variable `DBH`) is greater than 10 cm. But that particular value of diameter may vary. The code will be inclusive; it'll accept trees of all diameters and will only warn if it detects trees smaller or equal than 10 cm.

```{r}
# Expecting to reuse this code
check_dbh <- function(x, limit) {
  if (any(x <= limit)) {
    warning("The diameter of some trees is smaller or equal to ", limit, " cm")
  } else{
    invisible()
  }
}
check_dbh(filtered_plotid$DBH, 10)
```

Excluding trees smaller than the desired limit will be up to the user, either via a "`prepare_data()`" function, or directly with something like this:

```{r}
limit <- 10
over_limit <- filter(filtered_plotid, DBH > limit)
# Silent means that filtering was successful
check_dbh(over_limit$DBH, limit)
```

### Check for multiple censuses; warn if multiple censuses are detected.

I believe the map should inform only the latest `Status`. That is, if multiple censuses where done, only the last one will be used to inform that the `Status` of each stem was.

```{r}
if (length(unique(over_limit$CensusID)) > 1) {
  warning(
    "Multiple censuses were detected\n",
    "  * Filtering only the greatest `CensusID`"
  )
  last_census <- max(unique(over_limit$CensusID))
  is_last_census <- over_limit$CensusID == last_census
  over_limit <- over_limit[is_last_census, ]
}
```



## Map

### Requirements

For now I'll focus on a single quadrat. (I'll work later on the code to iterate over multiple quadrats.)

```{r}
# Choosing one quadrat at random
this_quadrat <- "4919"
one_quadrat <- filter(over_limit, QuadratName == this_quadrat)
```

The requirements are quoted below; they come from a private email (via [@](https://mail.google.com/mail/u/0/?zx=yxdmg1oh1mf4#search/is%3Aunread+OR+has%3Apurple-question/1600a06b2c2f4304))

* 1. Status: I'll map the `Status` of each stem to a the ending of each label. This is a better alternative than mapping to, say point shape, because each tree `Tag` has multiple stems associated to them, and they will reppel each other. If the `Status` was mapped to shape, multiple points will plot on top of each other and the overlapping will obscure the information.

>  It would be nice to include the status. I used to put a "D" (dead) or an "R"(stem lost or broken) after the tag number to differentiate them from the live trees. For example, 8334D or 8145R.

* 2. I won't label subquadrats inside eadh quadrat.

>  I don't need the subquadrat labels, since they are the same for every quadrat.

* 3. I'll fix the quadrat size to 20x20m. I'll keep in mind that this may need to be flexible in the future.

> 3. [In] most sites, the quadrats are 20x20 meters.

* 4. I'll map the shape of the point to an empty circle, and will map its size to the size of each tree, standarized by the number of trees the quadrat.

> It would be nice to have a larger circle for the larger trees so that the field workers can look for a large tree. However, for very crowded quadrats, we can ignore this or make the circles smaller than if there are less trees. In my script, I count the number of trees in that quadrat and calculate the size depending on the number.

* 5. Shape and position:

    * I'll map live trees to a circular shape. 
    * I'll map the position of each tree to a point, using the variables `x` and `y`.
    * Also, I'll map the position to the `Tag` name of each tree -- that way field workers will know what tree they expect to find where. To avoid overlap, I'll implement repulsive labels with `ggrepel::geom_text_repel()`.

> 5. For the live trees, yes, please use circles (tree trunks tend to be circular). But you are welcome to use other symbols for the "other" categories.

* 6. I'll remove all text from the axes;

> The reason I don't have the tick legends is to give more space to the map on the page.

* 7. I'll set the direction of the axes ticks to inward;

> Same reason as above, to make the map as large as possible on the page. However, I wouldn't mind if they are outwards.

* 8. I'll set the count of axes ticks to one meter along the range of `x` and `y` values;

> Yes, so that the field workers can orient themselves on the maps and more carefully draw the location of the trees.

* 9. I'll set one grid line every 5 meters along the range of `x` and `y` values;

> Yes, each grid represents a 5x5 m subquadrat. This is how the plots are physically gridded in the field.

* 10. I'll set he type of the grid lines to dashed.

> Dashed seems to me to be better than solid.

* 11. I'll add a one-line title; I'll to this at the top of the code to help visualize where on the plot each code chunk is doing its job.

> ... would be great if I can manually choose the title.

> The plotname in ViewFullTable carries the name of the plot.

* 12. I'll add a multi-line subtitile, wich I'll do in advance to avoid cluttering the code of the plot. Also, placing this code under the title will help to visualize where on the plot this code chunk is doing its job.

> I think each site would like to be able to type in their subheaders.

* I'll set the background colour to white;

(Eventually I'll let the user adjust these options -- but I'll do that later; now I focus on getting the maps close to the most common requirement.)

### Helpers

```{r}
theme <- theme(
  panel.background = element_rect(fill = "white"),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  legend.position = "none",
  plot.title = element_text(size = 20),
  plot.subtitle = element_text(size = 12),
  axis.text = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  axis.ticks.length = unit(-0.1, "cm")
)

# Add the ending ".d" to the `Tag` of dead stems.
tag_dead <- function(x, y) {
  is_dead <- y == "dead"
  x[is_dead] <- paste0(x[is_dead], ".", sub("^(.).*$", "\\1", y[is_dead]))
  x
}

# See if this works
tag_dead(x = c("tag1", "tag2"), y = c("dead", "alive"))

```

### Set paramenters

```{r params}
# Parameters that will likely become arguments of a function
lim_min <- 0
lim_max <- 20
subquadrat_side <- 5
size_label <- 2
# Adjust a margin around the plot area that ggplot2 inserts by default
offset <- 1
title <- paste("My Title", unique(one_quadrat$QuadratName), sep = ", ")
header <- paste0(
  "Nombres y fecha:           Revisado por:                Entrado en PC por:\n",
  "                                                                          \n",
  "__________________  __________________  __________________\n",
  "__________________  __________________  __________________\n",
  "__________________  __________________  __________________\n"
)
```

## Prepare

```{r}
one_quadrat <- mutate(
  one_quadrat, 
  # Tad dead trees
  tagged_tag = tag_dead(Tag, Status),
  # Standarize the size of the points by the total number of trees
  dbh_standarized = DBH / length(DBH)
)

dead <- filter(one_quadrat, Status == "dead")
```

## Plot

```{r}
ggplot(data = one_quadrat, aes(x = x, y = y)) +
  geom_point(aes(size = dbh_standarized), shape = 1) +
  geom_text_repel(aes(label = tagged_tag), size = size_label) +
  # /* Repeat for the dead trees, which are lost because dbh is NA
  geom_text_repel(data = dead, aes(label = tagged_tag), size = size_label) +
  # */
  labs(title = title, subtitle = header, x = NULL, y = NULL) +
  geom_vline(
    xintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  geom_hline(
    yintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  coord_fixed(
    xlim = c(lim_min + offset, lim_max - offset), 
    ylim = c(lim_min + offset, lim_max - offset)
  ) +
  scale_x_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  scale_y_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  theme
```


## Observe potential problem


I'm suprised that all trees are alive, and I wonder if this is an error.

```{r}
unique(one_quadrat$Status)
```

I'll check if the plot works if I introduce dead trees.

```{r}
with_dead <- one_quadrat
with_dead$Status[1:30] <- "dead"
with_dead$DBH[1:30] <- NA
```

Next I'll repeate the exact same preparation and plotting code.


## Prepare

```{r}
with_dead <- mutate(
  with_dead, 
  # Tad dead trees
  tagged_tag = tag_dead(Tag, Status),
  # Standarize the size of the points by the total number of trees
  dbh_standarized = DBH / length(DBH)
)

dead <- filter(with_dead, Status == "dead")
```

## Plot

```{r}
ggplot(data = with_dead, aes(x = x, y = y)) +
  geom_point(aes(size = dbh_standarized), shape = 1) +
  geom_text_repel(aes(label = tagged_tag), size = size_label) +
  # /* Repeat for the dead trees, which are lost because dbh is NA
  geom_text_repel(data = dead, aes(label = tagged_tag), size = size_label) +
  # */
  labs(title = title, subtitle = header, x = NULL, y = NULL) +
  geom_vline(
    xintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  geom_hline(
    yintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  coord_fixed(
    xlim = c(lim_min + offset, lim_max - offset), 
    ylim = c(lim_min + offset, lim_max - offset)
  ) +
  scale_x_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  scale_y_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  theme
```

## Explain why dead trees are plotted independently

This is why the tags are plotted twice -- once for the entire dataset and once of dead treed only. Deead trees have `DBH = NA`, which I get removed automatically by __ggplot2__ when `DBH` is passed to `geom_point()`. Below

```{r}
select(with_dead, DBH, Status, Tag, tagged_tag)
```

```{r}
ggplot(data = with_dead, aes(x = x, y = y)) +
  geom_point(aes(size = dbh_standarized), shape = 1) +
  geom_text_repel(aes(label = tagged_tag), size = size_label) +
  # /* Repeat for the dead trees, which are lost because dbh is NA
  # geom_text_repel(data = dead, aes(label = tagged_tag), size = size_label) +
  # */
  labs(title = title, subtitle = header, x = NULL, y = NULL) +
  geom_vline(
    xintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  geom_hline(
    yintercept = seq(lim_min, lim_max, by = subquadrat_side), 
    linetype = "dashed"
  ) +
  coord_fixed(
    xlim = c(lim_min + offset, lim_max - offset), 
    ylim = c(lim_min + offset, lim_max - offset)
  ) +
  scale_x_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  scale_y_continuous(breaks = lim_min:lim_max, sec.axis = dup_axis()) +
  theme
```

## My conclusion about dead trees not appearing on the example data

The last few sectios confirmed that the plot is able to map dead trees. The reason why the example data isn't showing dead trees is indeed because no alive tree is left after the filtering process I went through here. The issue remains to find out the filtering I'm doing is resonable or if I am inadvertedly removing dead trees. One way to check is to use real data -- not the minimal example data I used here -- and confirm that the plot shows trees that in the last census had `Status = "dead"`.

