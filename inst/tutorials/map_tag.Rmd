---
title: "Mapping Latest Tree-Status in Subquadrats"
author: "Mauro Lepore"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 6
vignette: >
  %\VignetteIndexEntry{Mapping Latest Tree Status in Subquadrats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE, message=FALSE, warning=FALSE}
# hadley's settings
set.seed(1014)
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  out.width = "98%",
  fig.align = "center",
  fig.width=7.5, 
  fig.asp = 0.9,
  fig.show = "hold"
)

library(ggplot2)
update_geom_defaults("text", list(size = 14.5))
```

```{r pkg-hide, echo=FALSE}
# install_github("forestgeo/try@iss1_map_tag")
library(try)

# Also using the package dplyr for easier data manipulation
# install.packages(dplyr)
library(dplyr)
# Print only a few rows of tibbles (modern dataframes) to save space
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Overview

This tutorial will show you you how to map the latest tree-status in subquadrats with `map_tag()`.

# Motivation

Imagine you need some maps to work in the field at the site Yosemite. All you need is a ViewFullTable and the function `map_tag()`.

```{r hide-sinh, echo=FALSE}
filter_first_quadrat <- function(vft) {
  first_quadrat <- unique(vft$QuadratName)[1]
  vft[vft$QuadratName == first_quadrat, ]
}
yose_vft <- filter_first_quadrat(yosemite::ViewFullTable_yosemite)
```

```{r}
# Using a private data set; and using only one quadrat for a small example
maps <- map_tag(yose_vft)
```

Here is the first set of four subquadrats.

```{r yose-print-screen}
maps[[1]]
```

You can output a .pdf with `pdf()`.

```{r yose-print-pdf}
pdf("example-yosemite.pdf", paper = "a4")
maps
dev.off()
```

This is what the saved .pdf looks like (scroll down the window below).

```{r, echo=FALSE}
knitr::include_graphics("example-yosemite.pdf")
```

## What `map_tag()` Does?

Let's review what has just happened. Although your ViewFullTable may have data of multiple censuses, `map_tag()` focuses exclusively on the latest census (via PlotNameCensus). `map_tag()` plots not the status of individual stems but the status of a tree. That is, if in the latest census at least one stem of a tree has status "alive", then `map_tag()` plots its status as "alive"; if no stem is "alive", `map_tag()` plots its status as "other". Why "other" and not "dead"? Because stems are classified not simply as "dead" or "alive": if it is not "alive", the value of `status` may be, for example, "dead" for one stem of a particular tree, and "broken below" for another stem of the same tree. Yet `map_tree()` is designed to plot only one value of status per indivudual tag. The solution is to group all values that are not "alive" into the single category "other".

Ok, that was the bad news -- `map_tag()` won't let you change the values of the variable `status`. The good news is that you can change almost anything else. You will learn how to do that in the rest of this tutorial.

# Preparation: Packages and Data

Currently, `map_tag()` lives in the __try__ package, but after I receive some feedback I will move it to the __forestr__. You will also use dplyr to make it easy to manupulate data. (A number of other packages are also used but only under the hoods -- you don't need to worry about them because they'll will be installed and used automatically.)

```{r pkg-show}
# install_github("forestgeo/try@iss1_map_tag")
library(try)

# Also using the package dplyr for easier data manipulation
# install.packages(dplyr)
library(dplyr)
# Print only a few rows of tibbles (modern dataframes) to save space
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

The data you will use from now on is an example dataset from Barro Colorado Island (made public in 2012; https://repository.si.edu/handle/10088/20925).

```{r data-vtf}
# Subset of a public ViewFullTable from BCI (source:
# https://repository.si.edu/handle/10088/20925).

# Convert to tibble (modern dataframe) for better printing
vft <- as_tibble(bci12vft_mini)
vft
```

Not all data sets may be named appropriately. `map_tag()` expects some variables to have specific names. If the name of your variables is different than expected, you'll get an error.

```{r rename-variables, error=TRUE}
# Fails
map_tag(vft)
```

Reading the error message will help you identify which variables you need to rename.

```{r fix-names}
renamed <- dplyr::rename(vft, qx = x, qy = y)
# Using lowercase names for simiplicity
names(renamed) <- tolower(names(renamed))
```

With the techniques you'll learn here, you can produce maps of an entire data set, or of just a few quadrats. To save space, let's focus just on any one quadrat -- any quadrat.

```{r filter-bci}
any_quadrat <- sample(unique(renamed$quadratname), 1)
vft1 <- filter(renamed, quadratname == any_quadrat)
vft1
```

# Customizing Your Maps

This section shows how you can change the default of your maps. Help is also available via `?map_tag()`. For example, you can customize the plot title, and the points and tags. 

```{r custom-title-point-shape}
maps <- map_tag(renamed, 
  site_name = "BCI 2012", point_size = 3, point_shape = c(17, 6), tag_size = 5
)
maps[1]
```

## Customizing The Header

The header is controlled by the argument `header`.

```{r custom-header}
map_tag(renamed, site_name = "BCI 2012", header = "My header")[[1]]
```

You can create a multi-line header by braking each line with "\\n".

```{r header-basic}
map_tag(renamed, site_name = "BCI 2012", 
  header = "Line 1: _________\nLine 2:\nLine 3:....................."
)[[1]]
```

But there is an alternative (easier) way: with `get_header()`. If you read signature of `map_tag()` (by running `map_tag`), you will notice that the default `header` is `header = get_header()` (see `?get_header()`).

```{r header-via-helper}
your_header <- get_header(
  line1 = "Your header-line 1: _____________________________",
  line2 = "Your header-line 3: _____________________________",
  line3 = "Your header-line 2: _____________________________"
)
map_tag(renamed, site_name = "BCI 2012", header = your_header)[[1]]
```

## Using Pre-Made and Custom Themes

Similarly to how you customized the header, you can also customize the plot theme. The argument `theme` defauls to `theme = get_theme()`, but you can either use any pre-made theme (see `?ggplot2::theme_bw`) or create a custom theme. This is how you can use a pre-made theme.

```{r pre-made-theme}
# Allow using pre-made themes (e.g. ggplot2::theme_bw()) and building custom
# themes (with ggplot::theme()).
library(ggplot2)

map_tag(renamed, site_name = "BCI 2012", theme = theme_gray())[[1]]
```

This is how you can use a custom theme (see `?ggplot2::theme()`).

```{r custom-theme}
# An extreeme example to show that themes are extreemely flexible
your_theme <- ggplot2::theme(
  legend.position = "bottom",
  legend.title = element_blank(),
  legend.text = element_text(size = 8, colour = "red"),
  text = element_text(size = 11, face = "bold.italic", colour = "white"),
  plot.background = element_rect(fill = "black"),
  plot.margin = margin(2, 2, 2, 2, "cm"),
  strip.background = element_rect(fill = "darkgreen"),
  strip.text = element_text(colour = "white"),
  # make grid to dissapear by matching background colour
  panel.background = element_rect(fill = "lightgreen"),
  panel.grid.minor = element_line(colour = "black", linetype = "dotted"),
  panel.grid.major = element_line(colour = "black")
)
map_tag(renamed, site_name = "BCI 2012", theme = your_theme)[[1]]
```

xxxconthere.

## Changing the Dimension of Quadrats and Subquadrats

## xxx Fix This

You can change the size of the quadrat and subquadrats. For example, here we define that side of each quadrat is 40 meters, and the side of eacdh subquadrat is 10 meters. Each map will always show 4 subquadrats of the 16 subquadrats that make up the quadrat.

```{r}
map_tag(renamed, site_name = "BCI 2012", 
  x_q = 40,  # side of a quadrat in meters
  x_sq = 10  # side of a subquadrat in meters
)[[1]]
```


```{r}
map_tag(renamed, site_name = "BCI 2012", 
  x_q = 80, x_sq = 40
)[[1]]
```



# Related Functions that Can Be Called Directly

`add_subquadrat()`

```{r}
df <- data.frame(
  qx = sample(1:20, 100, replace = TRUE),
  qy = sample(1:20, 100, replace = TRUE),
  stringsAsFactors = FALSE
)
df

with_subquadrat <- add_subquadrat(df, 20, 20, 5, 5)
head(with_subquadrat[c("qx", "qy", "subquadrat")])

ggplot(with_subquadrat, aes(qx, qy)) + 
  geom_point() +
  
add_subquad_limits



```





































