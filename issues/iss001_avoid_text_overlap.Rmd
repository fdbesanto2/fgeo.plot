---
title: "Avoid text overlap"
subtitle: "Example using data from Sinharaja"
author: "maurolepore@gmail.com"
date: "2017-09-20"
output:
  rmarkdown::html_document:
    toc: true
    toc_depth: 6
---

```{r setup, include=FALSE}
# > There is one chunk name that imbues special behaviour: setup. When you're in
# a notebook mode, the chunk named setup will be run automatically once, before
# any other code is run.
# --http://r4ds.had.co.nz/r-markdown.html#chunk-options



# Load packages (including data-packages) ----

library(tidyverse)
library(ggrepel)
library(try)



# Load un-packaged dependencies ----





# Figures ----

# > If you want to make sure the font size is consistent across all your
# figures, whenever you set out.width, you'll also need to adjust fig.width to
# maintain the same ratio with your default out.width. For example, if your
# default fig.width is 6 and out.width is 0.7, when you set out.width = "50%"
# you'll need to set fig.width to 4.3 (6 * 0.5 / 0.7).
# --http://r4ds.had.co.nz/

set.seed(1014)
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  out.width = "90%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 1,  # 1 / phi
  fig.show = "hold"
)

options(dplyr.print_min = 6, dplyr.print_max = 6)

# customize ggplot

update_geom_defaults("point",
  list(shape = 21, colour = "black", size = 2, stroke = 1)
)
update_geom_defaults("text", list(size = 2))
```

# Goal

To clearly plot information that help workers to identify specific trees on the field. Previous drafts were too crowded, with labels that overlapped and impaired reading the information clearly.

For each quadrat we want to output 4 plots, each showing 1/4 of the quadrat's area. Each of those sub-quadrat we want to plot in one separate page.

# Approach

* Overview the entire data to understand it.
* Pull one data frame.
    * Overview it.
    * Draft a plot quickly to see it we are heading in the right direction.
    * Divide it in 4 subplots.
    * Plot avoiding labels overploting.
        * aesthetics: 
            * `x`, `y` map to position in the quadrat, i.e. `lx`, `ly`.
            * text maps to `tag` id
            * shape or colour map to symbol



# Explore entire data set

> (To Stuart) Since there are 67 quadrats in your check list there will be 268 pages (4 per quad)
--Shameema

The name of each data frame, and their number (67) confirm they correspond to the name (or ID) of each quadrat.

```{r}
names(sin_q20)
```

Let's confirm that all 67 data frames in the list have the same variable names.

```{r}
# Yes. All data frames have exactly the same name.
unique(lapply(sin_q20, names))
```

Now let's overview the data set, paying special attention to the type of each variable.

```{r}
# Show only part of the entire data set to save space
n_cols_per_df <- unlist(unique(lapply(sin_q20, ncol)))
str(sin_q20[1:3])
```

`status` should probabbly be a character variable (data dictionary https://goo.gl/i6kHiQ) but here it is a factor.

```{r}
# map() is like lapply with some handy shortcuts
map(sin_q20, "status") %>% 
  map(unique) %>% 
  head()
```

The reason why `status` is a factor is probably because the data frames where built using the default `stringsAsFactors = TRUE`. Because it may cause problems, let's fix this now. We'll also take the chance to convert the variable `symbol` to a factor. This will later make plotting easier.

```{r}
convert_status_to_character <- function(x) {
  x$status <- as.character(x$status)
  x
}
convert_symbol_to_factor <- function(x) {
  x$symbol <- as.factor(x$symbol)
  x
}
sin_q20 <- lapply(sin_q20, convert_status_to_character)
sin_q20 <- lapply(sin_q20, convert_symbol_to_factor)

# Showing only a few data frames to save space
str(sin_q20[1:3])
```

These are the values of the variable `symbol`:

```{r}
sin_q20[[1]]$symbol %>% unique()
```

This is what they mean (after email by Shameema , https://goo.gl/S8KfWf):

* 16: filled circles on a map indicate trees that are alive in census4.
* 1: open circles indicate trees that were alive in census 3 but were found dead in census 4.
* 15: filled squares indicate trees that were alive in census 2 but did not survive to census 3.
* 0: open squares indicate trees that were alive in census 1 but did not live to census 2.

To make this easier to interpret, I'll use more explicit values.

```{r}
# Add alternatives to symbol, that are easier to understand
codify_explicitely <- function(x) {
  mutate(x, 
    sym1 = case_when(
      symbol == 16 ~ "Alive in 4",
      symbol ==  1 ~ "Alive in 3, Dead in 4",
      symbol == 15 ~ "Alive in 2, Dead in 3",
      symbol ==  0 ~ "Alive in 1, Dead in 2"
    ),
    sym2 = case_when(
      symbol == 16 ~ "Alive",
      symbol ==  1 ~ "Dead",
      symbol == 15 ~ "Dead",
      symbol ==  0 ~ "Dead"
    )
  )
}
sin_q20 <- map(sin_q20, codify_explicitely)
```



# Plot

Lets filter the lower left quarter of one quadrat and plot it. Later I can apply the same approach to all other quarters of each quadrat, and to all other quadrats.

From the entire data set, pull out only one data frame and overview it.

```{r}
# Filter lower left subsection
first_df <- as.tibble(sin_q20[[1]])
first_ll <- filter(first_df, lx <= 10, ly <= 10)
```



```{r}
ided <- identify_subquadrat(sin_q20)
head(ided)
tail(ided)
```




```{r}


# Tweak plot
point_size <- 1.5
id_size <- 3
text_size <- 15
shrink <- c(0.4, 9.6)
site_string <- "(Sinharaja)"

subtitle_string <- paste0(
  site_string,
  "\n",
  "\n",
  "Measuring: __________________ Measurement date: __________________\n",
  "\n",
  "Recording: __________________ Checking: __________________________\n",
  "\n",
  "Checked date: _______________",
  "\n"
)

theme <- theme(
  panel.grid.major = element_line(colour = "black"),
  panel.grid.minor = element_line(linetype = "dotted", colour = "black"),
  panel.background = element_rect(fill = 'white'),
  legend.position = "top",
  axis.ticks = element_blank(),
  legend.title = element_blank(),
  text = element_text(size = text_size) 
  )

plot_repel <- function(df) {
  ggplot(df, aes(x = lx, y = ly, shape = sym2)) +
    scale_shape_manual(values = c(19, 1)) +
    geom_point(size = point_size) +
    geom_text_repel(aes(label = tag), size = id_size) +
    scale_x_continuous(minor_breaks = seq(1, 20, 1), breaks = seq(0, 20, 5)) +
    scale_y_continuous(minor_breaks = seq(1, 20, 1), breaks = seq(0, 20, 5)) +
    coord_fixed(xlim = shrink, ylim = shrink) +
    labs(x = NULL, y = NULL) +
    theme + 
    labs(
      title = unique(df$details), 
      subtitle = subtitle_string
    )
}
```



```{r}


# xxx cont



df_list1 <- add_quadrat_to_df_list(df_list1)
df11 <- df_list1[[1]] %>% 
  filter(lx < 10, ly < 10) %>% 
  mutate(
    quadrat = paste0("Quadrat ", quadrat),
    quarter = paste0("-1"),
    details = paste(quadrat, quarter)
  )
p <- plot_repel(df11)
p



```
















```{r plot-repel, include=FALSE}
# a4 = 8.27, 11.69
pdf(paper = "a4", width = 8.2, height = 8.2)
p
dev.off()
```

Check that the values of `symbol` make sense:

```{r}
first_df %>% 
  select(status, symbol, sym1, sym2) %>% 
  unique()

# symbol means:
# * 16: filled circles on a map indicate trees that are alive in census4.
# *  1: open circles indicate trees that were alive in census 3 but were found
#       dead in census 4.
# * 15: filled squares indicate trees that were alive in census 2 but did not
#       survive to census 3.
# *  0: open squares indicate trees that were alive in census 1 but did not
#       live to census 2.
# (after email by Shameema , https://goo.gl/S8KfWf)
```



# xxx continue here: Iterate



```
unique(data$id) %>% 
  map(filter_df_by_id) %>%  ## These two may be wrapped in a function
  map(plot_df)              ##   plot_filtered_id()` as shown below
```


See `?try::lapply_plot_sp()` for inspiration about how to iterate over multiple plots and save each of them in one page of a single pdf file.

From the list I have, here is a prototype of the data I need to create:

```{r}
tribble(
      ~id,  ~site, ~quadrat, ~quarter, ~df,
  "sin11",  "sin",        1,        1,  "dfs11",
  "sin12",  "sin",        1,        2,  "dfs12",
  "sin13",  "sin",        1,        3,  "dfs13",
  "sin14",  "sin",        1,        4,  "dfs14"
)
```

Then the job is to plot the df of each id. So the plot may be faceted by id so that all the useful info appears in each plot.

* I need a function that filters df by id
* Then, I need a function that plots the df filtered before.
* I need a function that wraps the two steps above.
* Finally, I need to wrap all of this in `pdf()`.

```
pdf(onefile = TRUE)
unique(data$id) %>% 
  map(filter_df_by_id) %>%  ## These two may be wrapped in a function
  map(plot_df)              ##   plot_filtered_id()` as shown below
dev.off()
```
Same:

```
pdf(onefile = TRUE)
map(unique(data$id), plot_filtered_id)
dev.off()
```

