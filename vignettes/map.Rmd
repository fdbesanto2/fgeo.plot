---
title: "Mapping Functions"
author: "Mauro Lepore"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 6
vignette: >
  %\VignetteIndexEntry{Mapping Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette shows the same code that you can find in the help files of `maply_sp_elev()`, `maply_quad()` and `maply_tag()`, but here you can see the output.

```{r}
library(fgeo.map)
library(fgeo.tool)
library(dplyr)
# Avoid conflict with `stats::filter()`
filter <- dplyr::filter
```

```{r setup, echo = FALSE, message=FALSE, warning=FALSE}
# hadley's settings
set.seed(1014)
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  out.width = "98%",
  fig.align = "center",
  fig.width = 7.5, 
  # fig.show = "hold",
  fig.asp = 0.9
)
```

# maply\_quad(): Map trees within a quadrat

```{r}
# Filter the data you want. For example:
# (see ?top4quad)
want <- filter(
  top4quad,
  CensusID == 6,
  PlotID == 1
)
p <- maply_quad(want)
# Visualizing only the first plot of `p`
first(p)
# Printing all plots of `p` to .pdf, with parameters optimized for size letter
pdf("map.pdf", paper = "letter", height = 10.5, width = 8)
p
dev.off()

# Be careful if filtering by DBH: You may unintentionally remove dead trees.
# * Confirm this dataset has dead trees:
# (see `?top4quad`)
dead <- top4quad %>%
  add_status_tree(status_a = "alive", status_d = "dead") %>%
  row_top(QuadratID) %>%
  filter(status_tree == "dead")
select(dead, Tag, Status, status_tree, DBH)
maply_quad(dead)
# * If you filter by `DBH`, you loose the dead trees becaue their `DBH = NA`
wrong <- filter(dead, DBH > 10)
maply_quad(wrong)
# * The right way to do it is to explicietly inlcude rows where DBH = NA
right <- filter(dead, DBH > 10 | is.na(DBH))
maply_quad(right)

# Keeping dead trees with `is.na(DBH)` (e.g. tag 127885.d on the bottom right)
p <- filter(top4quad, DBH > 20 | is.na(DBH))
first(maply_quad(p))

# For more complex filtering, see also ?fgeo.tool::row_discard_twice_dead)

# Customizing the maps ----------------------------------------------------

# A custom title and header
myheader <- paste(
  " ",
  "Head column 1                     Head column 2                          ",
  " ",
  " ........................................................................",
  " ........................................................................",
  sep = "\n"
)
# See ?top1quad
maply_quad(top1quad, title_quad = "My Site, 2018. Quad:", header = myheader)

# Tweak the theme with ggplot
library(ggplot2)

maply_quad(
  top1quad,
  title_quad = "My Site, 2018. Quad:",
  header = map_quad_header("spanish"),
  tag_size = 3,
  theme = theme_map_quad(
    axis.text = NULL,  # NULL shows axis.text; element_blank() doesn't.
    plot.title = element_text(size = 15),
    plot.subtitle = element_text(size = 5),
    panel.background = element_rect(fill = "grey")
  )
)
```



# maply\_tag(): Map tree tags by status

```{r}
# Filtering the data to map -----------------------------------------------

# Filter the data you want. For example:
# (see ?top1quad)
want <- filter(
  top1quad,
  CensusID == 6,
  PlotID == 1
)
p <- maply_tag(want)
# Visualizing only the first plot of `p`
first(p)
# Printing all plots of `p` to .pdf, with parameters optimized for size letter
pdf("map.pdf", paper = "letter", height = 10.5, width = 8)
p
dev.off()

# Be careful if filtering by DBH: You may unintentionally remove dead trees.
# * Confirm this dataset has dead trees:
# (see `?top4quad`)
dead <- top4quad %>%
  add_status_tree(status_a = "alive", status_d = "dead") %>%
  row_top(QuadratID) %>%
  filter(status_tree == "dead")
select(dead, Tag, Status, status_tree, DBH)
first(maply_tag(dead))
# * If you filter by `DBH`, you loose the dead trees becaue their `DBH = NA`
wrong <- filter(dead, DBH > 10)
wrong
# * The right way to do it is to explicietly inlcude rows where DBH = NA
right <- filter(dead, DBH > 10 | is.na(DBH))
right
first(maply_quad(right))

# Keeping dead trees with `is.na(DBH)` (e.g. tag 127885.d on the bottom right)
p <- filter(top4quad, DBH > 20 | is.na(DBH))
first(maply_tag(p))

# For more complex filtering, see also ?fgeo.tool::row_discard_twice_dead

# Customizing the maps ----------------------------------------------------

# Common tweaks

p <- maply_tag(top1quad, show_page = FALSE, show_subquad = FALSE)
first(p)

p <- maply_tag(
  top1quad,
  title_quad = "BCI 2012. Quadrat: ",
  bl = "bottom-left", br = "bottom-right", tr = "top-right", tl = "top-left",
  header = "Line 1: _________\nLine 2:\nLine 3:.....................",
  subquad_offset = -1,
  point_size = 3, point_shape = c(17, 6),
  tag_size = 2,
  move_edge = 0.5
)
first(p)



# Themes

library(ggplot2)

p <- maply_tag(top1quad, theme = theme_gray())
first(p)

# Tweaking the default theme of maply_tag()

small_tweak <- theme_map_tag(legend.position = "bottom")
p <- maply_tag(top1quad, theme = small_tweak)
first(p)

large_tweak <- theme(
  legend.position = "bottom",
  legend.title = element_blank(),
  legend.text = element_text(size = 8, colour = "red"),
  text = element_text(size = 11, face = "bold.italic", colour = "white"),
  plot.background = element_rect(fill = "black"),
  plot.margin = margin(2, 2, 2, 2, "cm"),
  strip.background = element_rect(fill = "darkgreen"),
  strip.text = element_text(colour = "white"),
  # make grid to dissapear by matching background colour
  panel.background = element_rect(fill = "lightgreen"),
  panel.grid.minor = element_line(colour = "black", linetype = "dotted"),
  panel.grid.major = element_line(colour = "black")
)
p <- maply_tag(top1quad, theme = large_tweak)
first(p)



# Quadrat and subquadrat dimensitons

# Adapting the dimensions of quadrat and subquadrat to the range of qx and qy
# Creating new data set with QX and QY ranging 0-100
smaller <- top1quad
n <- nrow(smaller)
smaller$QX <- sample(0:10, n, replace = TRUE)
smaller$QY <- sample(0:10, n, replace = TRUE)

p <- maply_tag(smaller, x_q = 10, x_sq = 2.5)
first(p)

# If limit-lines aren't visible, try extending the grid a little
p <- maply_tag(smaller, x_q = 10, x_sq = 2.5, move_edge = 0.25)[1]
first(p)
```





# maply\_sp\_elev(): Map species and elevation data

```{r}
census <- fgeo.tool::row_top(bciex::bci12s7mini, sp, 2)
elevation <- bciex::bci_elevation

# Map on multiple pages ---------------------------------------------------

p1 <- maply_sp_elev(census)
# Showing first map only.
p1[[1]]

p2 <- maply_sp_elev(census, elevation)
# Showing second map only.
p2[[2]]

# Tweaking
p3 <- maply_sp_elev(
  census,
  elevation,
  species = "all",
  fill = "white",
  shape = 21,
  point_size = 5,
  contour_size = 1,
  low = "grey",
  high = "black",
  hide_legend_color = TRUE,
  bins = 7,
  label_elev = FALSE
)
p3[[1]]

# Map on a single page (maybe multiple panels) ----------------------------

# Simplest way to map elevation data only
map_elev(elevation)

map_sp_elev(census)

map_sp_elev(census, elevation)

# For maximum control, you can compose maps as you like

# Traditional: g(f(x))
contour_elev(map_gx_gy_elev(elevation))

# With the pipe: f(x) %>% g()
map_gx_gy_elev(elevation) %>%
  contour_elev()

# With traditional sintax: As you add more functions readability decreases.
theme_default(
  wrap(
    add_sp(
      hide_legend_color(
        hide_axis_labels(
          label_elev(
            contour_elev(
              limit_gx_gy(
                map_gx_gy_elev(elevation),
                xlim = c(0, 1200)
              ),
              contour_size = 0.5
            ),
            label_color = "red"
          )
        )
      ), census, point_size = 5
    ), "sp"
  ), legend.position = "top"
)

# Same with the pipe: As you add more functions readability doesn't change
map_gx_gy_elev(elevation) %>%
  limit_gx_gy(xlim = c(0, 1200)) %>%
  contour_elev(contour_size = 0.5) %>%
  label_elev(label_color = "red") %>%
  hide_axis_labels() %>%
  hide_legend_color() %>%
  add_sp(census, point_size = 5) %>%
  wrap("sp") %>%
  theme_default(legend.position = "top")
```

